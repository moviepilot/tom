require "em-synchrony/fiber_iterator"

module Tom
  class Dispatcher

    # Dispatches this request to all adapters that registered
    # for the route and then calls the merger for this route
    # to compose a response
    #
    # @param env [Array] A rack env object
    #
    # @return [Array] Whatever {Tom::Dispatcher.merge} had to say
    def self.dispatch(env)
      route, method = route_and_method(env)
      adapters = Tom::Routes.adapters_for_route(route, method)
      return [404, {}, '{reason: "No adapters for this route"}'] if adapters.empty?

      # Hit APIs. All at the same time. Oh, mygodd!
      responses = {}
      Tom::LOG.info "#{env['REQUEST_METHOD'].upcase} #{env['REQUEST_URI']}"
      Tom::LOG.info "Dispatching to:"
      EM::Synchrony::FiberIterator.new(adapters, adapters.count).map do |clazz|
        Tom::LOG.info "  -> #{clazz}"
        (responses[clazz] ||= []) <<  clazz.new.handle(env)
      end

      merged = merge(env, responses)
      Tom::LOG.info "-------------------------------------------------------n"
      merged
    end

    # Takes a request (rack env) and a couple of responses
    # generated by api adapters and composes a response for the
    # client.
    #
    # The merger used depends on the route.
    #
    # @param env [Array] A rack env object
    #
    # @return [Array] The merged result of all requests
    #   made as an array of status code, headers and body, e.g.
    #   [200, {}, "Hi!"]
    def self.merge(env, responses)
      route, method = route_and_method(env)
      merger = Tom::Routes.merger_for_route(route, method)
      Tom::LOG.info "Merging with:"
      Tom::LOG.info "  -> #{merger}"
      merger.new.merge env, responses
    end



    # Extract the route/request uri and the method from a
    # rack env
    #
    # @param env [Hash] A rack env
    #
    # @return [Array] Contains request_path, request_method as symbols
    def self.route_and_method(env)
      [env["REQUEST_PATH"],
       env["REQUEST_METHOD"].downcase.to_sym]
    end

  end
end
